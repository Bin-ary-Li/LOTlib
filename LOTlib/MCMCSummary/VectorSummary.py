import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from matplotlib.widgets import RadioButtons, Slider
from MCMCSummary import MCMCSummary


class VectorSummary(MCMCSummary):
    """
    Summarize & plot data for MCMC with a VectorHypothesis (e.g. GrammarHypothesis).

    """
    def __init__(self, skip=100, cap=100):
        MCMCSummary.__init__(self, skip=skip, cap=cap)

    def zip_vector(self, idxs):
        """Return a n-long list - each member is a time series of samples for a single vector item.

        In `self.samples`, we have a list of samples; basically instead of this:
            [sample1, sample2, sample3, ...]

        We want to return this:
            [[s1[0], s2[0], s3[0], ...], [s1[1], s2[1], s3[1], ...], ...]

        """
        zipped_vector = zip(*[[s.value[i] for i in idxs] for s in self.samples])
        zipped_vector = [np.array(l) for l in zipped_vector]
        return zipped_vector

    def median_value(self, idxs=None):
        """Return a vector for the median of each value item accross `self.samples`, items in `idxs`."""
        if idxs is None:
            idxs = range(1, self.samples[0].n)
        vector_data = self.zip_vector(range(1, idxs))
        return [np.mean(v) for v in vector_data]

    def mean_value(self, idxs=None):
        """Return a vector for the mean of each value item accross `self.samples`, items in `idxs`."""
        if idxs is None:
            idxs = range(1, self.samples[0].n)
        vector_data = self.zip_vector(idxs)
        return [np.mean(v) for v in vector_data]

    def mean_gh(self, idxs=None):
        value = self.mean_value(idxs)
        gh = self.samples[idxs[-1]].__copy__()
        gh.set_value(value)
        gh.update_posterior()
        return gh

    # --------------------------------------------------------------------------------------------------------
    # Gridplot
    #
    # This doesn't work yet!  But when it does, it will hopefully be awesome and super-useful!
    #

    def draw_plot(self, idx, plot_type='violin'):
        """Plot predictive dist., rule sampling dist, & top hypotheses, all together with 1 slider.

        This slider controls which sample we are on, so we can see how things change over samples with MCMC.

        TODO:
          * Top Hypotheses listed in a subplot (neatly... maybe in a table?)
          * Test everything......

        """

        # Numpy array of sampled values for each vector element altered in proposals
        s0 = self.samples[0]
        propose_idxs = s0.propose_idxs

        # Set up initial violinplot
        fig, axs = plt.subplots(3)

        # Create subplots for each of our panels
        ax_bars    = axs[0]
        ax_samples = axs[1]
        ax_top_h   = axs[2]

        self.draw_rulesplot(idx)
        self.draw_predictive(idx)
        self.draw_tophypo(idx)

        return fig, axs

        # ax_radio1  = plt.subplot(gs.new_subplotspec((3, 3), rowspan=2, colspan=1))
        # ax_radio2  = plt.subplot(gs.new_subplotspec((5, 3), rowspan=2, colspan=1))
        #
        # # Radio button to set plot_type
        # def set_plottype(plot_type):
        #     plot_type = plot_type
        #     redraw(plot_type)
        # radio1 = RadioButtons(ax_radio1, ('violin', 'value', 'post', 'MLE', 'MAP'))
        # radio1.on_clicked(set_plottype)
        #
        # # Radio button should set gh_key (mean, MLE, MAP, recent)
        # def set_ghkey(gh_key):
        #     gh_key = gh_key
        #     redraw(self)
        # radio2 = RadioButtons(ax_radio2, ('mean', 'MLE', 'MAP', 'recent'))
        # radio2.on_clicked(set_ghkey)

    def draw_rulesplot(self, idx, plot_type='violin'):
        """Draw violinplot or lineplot of vector samples, or a plot of a GrammarHypothesis metric.

        This does different things depending on what we set `plot_type` as in `self.gridplot`.

        """
        if plot_type == 'violin':
            draw_violinplot(idx)
        if plot_type == 'values':
            draw_lineplot(idx)
        if plot_type in ('post', 'MLE', 'MAP'):
            draw_ghmetric(idx)

        def draw_violinplot(idx):
            vector_data = self.zip_vector(propose_idxs)
            data = [vector[0:idx] for vector in vector_data]
            y_labels = [s0.rules[i].short_str() for i in propose_idxs]
            ax_samples.set_title('Distribution of values over GrammarRules generated by MH')
            try:
                vplot = ax_samples.violinplot(data, points=100, vert=False, widths=0.7,
                                        showmeans=True, showextrema=True, showmedians=True)
            except Exception:     # seems to get LinAlgError, ValueError when we have single-value vectors
                vplot = None
            ax_samples.set_yticks(range(1, len(propose_idxs)+1))
            ax_samples.set_yticklabels(y_labels)
            return vplot

        def draw_lineplot(idx):
            # TODO: set X-axis here to be self.sample.count
            # TODO: only do data[0:idx]
            vector_data = self.zip_vector(propose_idxs)
            data = [vector[0:idx] for vector in vector_data]
            y_labels = [s0.rules[i].short_str() for i in propose_idxs]

            # TODO: make this divide `ax_samples` into subplots
            # N subplots sharing both x/y axes
            n = len(propose_idxs)
            ## f, AXES = plt.subplots(n, sharex=True, sharey=True)
            # ==> use `ax_samples`
            AXES[0].set_title('\tGrammar Priors as a Function of MCMC Samples')
            y_min = math.ceil(min([v for vector in vector_data for v in vector]))
            y_max = math.ceil(max([v for vector in vector_data for v in vector]))
            for i in range(n):
                AXES[i].plot(data[i])
                AXES[i].set_yticks(np.linspace(y_min, y_max, 5))
                # axs[i].scatter(vector_data[i])
                rule_label = AXES[i].twinx()
                rule_label.set_yticks([0.5])
                rule_label.set_yticklabels([y_labels[i]])

            ### Fine-tune figure; make subplots close to each other and hide x ticks for all but bottom plot.
            ## f.subplots_adjust(hspace=0)
            ## plt.setp([a.get_xticklabels() for a in f.axes[:-1]], visible=False)

    def draw_ghmetric(idx, metric='post'):
        # TODO: only do from [0:idx]
        ax_samples.set_title(metric + ' for GrammarHypotheses Sampled by MCMC')
        if metric == 'post':
            mcmc_values = [gh.posterior_score for gh in self.samples]
        elif metric == 'MAP':
            mcmc_values = [gh.max_a_posteriori() for gh in self.samples]
        elif metric == 'MLE':
            mcmc_values = [gh.max_like_estimate() for gh in self.samples]
        else:
            mcmc_values = []
        ax_samples.plot(mcmc_values)

    # --------------------------------------------------------------------------------------------------------
    # --------------------------------------------------------------------------------------------------------
    # Plotting methods  (this stuff is tested & it works!)  [except for predictive...]
    # --------------------------------------------------------------------------------------------------------
    # --------------------------------------------------------------------------------------------------------

    def plot(self, plot_type='violin'):
        assert plot_type in ('violin', 'values', 'post', 'MLE', 'MAP', 'barplot'), "invalid plot type!"
        if plot_type == 'violin':
            return self.violinplot_value()
        if plot_type == 'values':
            self.lineplot_value()
        if plot_type in ('post', 'MLE', 'MAP'):
            self.lineplot_gh_metric(metric=plot_type)
        if plot_type == 'barplot':
            self.plot_predictive()

    def violinplot_value(self):
        """
        TODO: doc?

        """
        # Numpy array of sampled values for each vector element altered in proposals
        s0 = self.samples[0]
        propose_idxs = s0.propose_idxs

        def draw_violinplot(value):
            """Clear axis & draw a labelled violin plot of the specified data.

            Note:
              * [fixed] If we haven't accepted any proposals yet, all our data is the same and this causes
                a singular matrix 'LinAlgError'

            """
            vector_data = self.zip_vector(propose_idxs)
            data = [vector[0:value] for vector in vector_data]

            ax.clear()
            ax.set_title('Distribution of values over GrammarRules generated by MH')
            try:
                vplot = ax.violinplot(data, points=100, vert=False, widths=0.7,
                                      showmeans=True, showextrema=True, showmedians=True)
            except Exception:     # seems to get LinAlgError, ValueError when we have single-value vectors
                vplot = None
            ax.set_yticks(range(1, len(propose_idxs)+1))
            y_labels = [s0.rules[i].short_str() for i in propose_idxs]
            ax.set_yticklabels(y_labels)

            fig.canvas.draw_idle()
            return vplot

        # Set up initial violinplot
        fig, ax = plt.subplots()
        fig.subplots_adjust(bottom=0.2, left=0.1)
        violin_stats = draw_violinplot(self.sample_count)

        # Slider updates violinplot as a function of how many samples have been generated
        slider_ax = plt.axes([0.1, 0.1, 0.8, 0.02])
        slider = Slider(slider_ax, "after N samples", valmin=1., valmax=self.sample_count, valinit=1.)
        slider.on_changed(draw_violinplot)

        plt.show()
        return violin_stats

    def lineplot_value(self):
        """
        http://matplotlib.org/examples/pylab_examples/subplots_demo.html

        """
        # Numpy array of sampled values for each vector element altered in proposals
        s0 = self.samples[0]
        propose_idxs = s0.propose_idxs
        n = len(propose_idxs)
        y_labels = [s0.rules[i].short_str() for i in propose_idxs]
        vector_data = self.zip_vector(propose_idxs)

        # N subplots sharing both x/y axes
        f, axs = plt.subplots(n, sharex=True, sharey=True)
        axs[0].set_title('\tGrammar Priors as a Function of MCMC Samples')
        y_min = math.ceil(min([v for vector in vector_data for v in vector]))
        y_max = math.ceil(max([v for vector in vector_data for v in vector]))
        for i in range(n):
            axs[i].plot(vector_data[i])
            axs[i].set_yticks(np.linspace(y_min, y_max, 5))
            # axs[i].scatter(vector_data[i])
            rule_label = axs[i].twinx()
            rule_label.set_yticks([0.5])
            rule_label.set_yticklabels([y_labels[i]])

        # Fine-tune figure; make subplots close to each other and hide x ticks for all but bottom plot.
        f.subplots_adjust(hspace=0)
        plt.setp([a.get_xticklabels() for a in f.axes[:-1]], visible=False)
        plt.show()

    def lineplot_gh_metric(self, metric='post'):
        """
        Draw a line plot for the GrammarHypothesis, evaluated by GH.posterior_score, MAP, or MLE.

        """
        assert metric in ('post', 'MLE', 'MAP'), "invalid plot metric!"
        fig, ax = plt.subplots()
        fig.subplots_adjust(bottom=0.2, left=0.1)
        ax.set_title('Evaluation for GrammarHypotheses Sampled by MCMC')

        if metric == 'post':
            mcmc_values = [gh.posterior_score for gh in self.samples]
        elif metric == 'MAP':
            mcmc_values = [gh.max_a_posteriori() for gh in self.samples]
        elif metric == 'MLE':
            mcmc_values = [gh.max_like_estimate() for gh in self.samples]
        else:
            mcmc_values = []
        ax.plot(mcmc_values)
        plt.show()

    def plot_predictive(self):
        """Visualize p(y \in C) over each y in the domain.

        This will be either the MLE GrammarHypothesis, the MAP, the most recent, or the mean averaged vector.

        This should be like the bar graphs in Josh Tenenbaum / Kevin Murphy's 'Bayesian Concept Learning'.

        Notes:
            * for now, this is only built for NumberGameHypothesis.
            * this should be 3 barplots: bayesian model averaging (weighted likelihood), MLE, & MAP
              ==> can these just be combined on 1 plot?  ==> checkbox instead of radiobutton? (future)

            * For now, just do 'recent' (not mean, MLE, MAP)

        """
        # Update the bar plots when you move the slider



        # draw_barplots(self.sample_count-1)


        return None
    '''
    # Slider updates violinplot as a function of how many samples have been generated
    slider_ax = plt.axes([0.1, 0.1, 0.8, 0.02])
    slider = Slider(slider_ax, "after N samples",
                valmin=1., valmax=self.sample_count, valinit=self.sample_count-1)
    slider.on_changed(draw_barplots)
    '''
    # plt.show()

    def draw_barplots(self, idx, plot_type='recent'):
        fig, ax = plt.subplots()
        # fig.subplots_adjust(bottom=0.2, left=0.1)
        idxs = range(0, int(idx))
        if plot_type == 'recent':
            gh = self.samples[int(idx)]
        if plot_type == 'mean':
            gh = self.mean_gh(idxs)     # TODO: does this work?????
        if plot_type == 'MAP':
            gh = self.get_top_samples(n=1, s_idxs=idxs, key=(lambda x: x.posterior_score))[0]
        if plot_type == 'MLE':
            gh = self.get_top_samples(n=1, s_idxs=idxs, key=(lambda x: x.likelihood))[0]

        print '!'*100
        print int(idx)
        print gh.value
        print [r.p for sublist in gh.grammar.rules.values() for r in sublist]
        # print gh.posterior_score, gh.likelihood, gh.prior
        # print gh.get_top_hypotheses()
        # print '!'*100

        domain = range(1, gh.hypotheses[0].domain+1)
        p_in_concept = gh.in_concept_avg(domain)

        ax.set_title('Distribution of values at '+str(idx)+' over GrammarRules generated by MH')
        ax.bar(domain, [p_in_concept[key] for key in p_in_concept.keys()])
        ax.set_yticks(np.arange(0., 1.2, .2))
        # fig.canvas.draw()
        return fig



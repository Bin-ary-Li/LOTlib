<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LOTlib.FunctionNode &mdash; LOTlib 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="LOTlib 1.0.0 documentation" href="../../index.html" />
    <link rel="up" title="LOTlib" href="../LOTlib.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">LOTlib 1.0.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../LOTlib.html" accesskey="U">LOTlib</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for LOTlib.FunctionNode</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	A function node -- a tree part representing a function and its arguments. </span>
<span class="sd">	Also used for PCFG rules, where the arguments are nonterminal symbols. </span>
<span class="sd">	</span>
<span class="sd">	A Functionnode defaultly iterates over its subnodes</span>
<span class="sd">	</span>
<span class="sd">	TODO: This could use some renaming FunctionNode.bv is not really a bound variable--its a list of rules that were added</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">LOTlib.Miscellaneous</span> <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="list2FunctionNode"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.list2FunctionNode">[docs]</a><span class="k">def</span> <span class="nf">list2FunctionNode</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s">&quot;atis&quot;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Take a list and map it to a function node. </span>
<span class="sd">		This will take lambda arguments of some given style (e.g. atis, scheme, etc)</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> 
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
		<span class="k">elif</span> <span class="n">style</span> <span class="ow">is</span> <span class="s">&#39;atis&#39;</span><span class="p">:</span>
			<span class="n">rec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">list2FunctionNode</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">)</span> <span class="c"># a wrapper to my recursive self</span>
			<span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;lambda&#39;</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">FunctionNode</span><span class="p">(</span><span class="s">&#39;FUNCTION&#39;</span><span class="p">,</span> <span class="s">&#39;lambda&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">rec</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">])],</span> <span class="n">generation_probability</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">bv_type</span><span class="o">=</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bv_args</span><span class="o">=</span><span class="bp">None</span> <span class="p">)</span> <span class="c">## TOOD: HMM WHAT IS THE BV?</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">FunctionNode</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">map</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">generation_probability</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">sytle</span> <span class="ow">is</span> <span class="s">&#39;scheme&#39;</span><span class="p">:</span>
			<span class="k">pass</span> <span class="c">#TODO: Add this scheme functionality -- basically differnet handling of lambda bound variables</span>
			
	<span class="k">else</span><span class="p">:</span> <span class="c"># for non-list</span>
		<span class="k">return</span> <span class="n">l</span>

<span class="c"># just because this is nicer, and allows us to map, etc. </span></div>
<div class="viewcode-block" id="isFunctionNode"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.isFunctionNode">[docs]</a><span class="k">def</span> <span class="nf">isFunctionNode</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">FunctionNode</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="cleanFunctionNodeString"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.cleanFunctionNodeString">[docs]</a><span class="k">def</span> <span class="nf">cleanFunctionNodeString</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Make functionNode strings easier to read</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;lambda&quot;</span><span class="p">,</span> <span class="s">u&quot;</span><span class="se">\u03BB</span><span class="s">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c"># make lambdas the single char</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="c"># remove underscores</span>
	<span class="k">return</span> <span class="n">s</span>
	
</div>
<div class="viewcode-block" id="FunctionNode"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode">[docs]</a><span class="k">class</span> <span class="nc">FunctionNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		NOTE: If a node has [ None ] as args, it is treated as a thunk</span>
<span class="sd">		</span>
<span class="sd">		bv - stores the actual *rule* that was added (so that we can re-add it when we loop through the tree)</span>
<span class="sd">		</span>
<span class="sd">		My bv stores the particlar *names* of variables I&#39;ve introduced</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">returntype</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">generation_probability</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">resample_p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">bv_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bv_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bv_args</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bv_prefix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bv_p</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ruleid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
		
	<span class="c"># make all my parts the same as q (not copies)</span>
<div class="viewcode-block" id="FunctionNode.setto"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.setto">[docs]</a>	<span class="k">def</span> <span class="nf">setto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
			</div>
	<span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shallow</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Copy a function node</span>
<span class="sd">			shallow - if True, this does not copy the children (self.to points to the same as what we return)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">shallow</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">newargs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> 
		<span class="k">else</span><span class="p">:</span>
			<span class="n">newargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>
		
		<span class="k">return</span> <span class="n">FunctionNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">returntype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newargs</span><span class="p">,</span> <span class="n">generation_probability</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generation_probability</span><span class="p">,</span> <span class="n">resample_p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resample_p</span><span class="p">,</span> <span class="n">bv_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_type</span><span class="p">,</span> <span class="n">bv_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_name</span><span class="p">,</span> <span class="n">bv_args</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_args</span><span class="p">),</span> <span class="n">bv_prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_prefix</span><span class="p">,</span> <span class="n">bv_p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_p</span><span class="p">,</span> <span class="n">ruleid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ruleid</span><span class="p">)</span>
	
<div class="viewcode-block" id="FunctionNode.is_nonfunction"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.is_nonfunction">[docs]</a>	<span class="k">def</span> <span class="nf">is_nonfunction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span></div>
<div class="viewcode-block" id="FunctionNode.is_function"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.is_function">[docs]</a>	<span class="k">def</span> <span class="nf">is_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_nonfunction</span><span class="p">()</span>
	</div>
<div class="viewcode-block" id="FunctionNode.as_list"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.as_list">[docs]</a>	<span class="k">def</span> <span class="nf">as_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			This returns ourself structured as a lisp (with function/self.name first)</span>
<span class="sd">			NOTE: This does ot handle BV yet</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span> <span class="k">else</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span> <span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span> <span class="p">)</span>
		<span class="k">return</span> <span class="n">x</span>
	</div>
<div class="viewcode-block" id="FunctionNode.islambda"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.islambda">[docs]</a>	<span class="k">def</span> <span class="nf">islambda</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Is this a lambda node? Using this function allows us to potentially </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;lambda&#39;</span><span class="p">)</span>
		
		<span class="c"># A nice place to keep this--will get checked a lot!</span>
		<span class="k">if</span> <span class="n">ret</span><span class="p">:</span> <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;*** Lambdas must have exactly 1 arg&quot;</span>
		
		<span class="k">return</span> <span class="n">ret</span>
	
	<span class="c"># output a string that can be evaluated by python</span>
	<span class="c">## NOTE: Here we do a little fanciness -- with &quot;if&quot; -- we convert it to the &quot;correct&quot; python form with short circuiting instead of our fancy ifelse function</span></div>
<div class="viewcode-block" id="FunctionNode.pystring"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.pystring">[docs]</a>	<span class="k">def</span> <span class="nf">pystring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
		<span class="c">#print &quot;&gt;&gt;&quot;, self.name</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_nonfunction</span><span class="p">():</span> <span class="c"># a terminal</span>
			<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;if_&quot;</span><span class="p">:</span> <span class="c"># this gets translated</span>
			<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;if_ requires 3 arguments!&quot;</span>
			<span class="k">return</span> <span class="s">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39; if &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39; else &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39;)&#39;</span>
			<span class="c">#return &#39;(&#39; + str(self.args[1]) + &#39;) if (&#39; + str(self.args[0]) + &#39;) else (&#39; + str(self.args[2]) + &#39;)&#39;</span>
		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
			<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Null names must have exactly 1 argument&quot;</span>
			<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;apply_&#39;</span><span class="p">:</span>
			<span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Apply requires exactly 2 arguments&quot;</span>
			<span class="k">return</span> <span class="s">&#39;(&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;)(&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;)&#39;</span>
		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">islambda</span><span class="p">():</span>
			<span class="c"># The old version (above) wrapped in parens, but that&#39;s probably not necessary?</span>
			<span class="k">return</span> <span class="s">&#39;lambda &#39;</span><span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bv_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;()&#39;</span> <span class="c"># simple call</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;(&#39;</span><span class="o">+</span><span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">))</span><span class="o">+</span><span class="s">&#39;)&#39;</span>
	</div>
<div class="viewcode-block" id="FunctionNode.quickstring"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.quickstring">[docs]</a>	<span class="k">def</span> <span class="nf">quickstring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			A (maybe??) faster string function used for hashing -- doesn&#39;t handle any details and is meant</span>
<span class="sd">			to just be quick</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="c"># simple call</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">+</span><span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">))</span> 
		</div>
<div class="viewcode-block" id="FunctionNode.fullprint"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.fullprint">[docs]</a>	<span class="k">def</span> <span class="nf">fullprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; A handy printer for debugging&quot;&quot;&quot;</span>
		<span class="n">tabstr</span> <span class="o">=</span> <span class="s">&quot;  .  &quot;</span> <span class="o">*</span> <span class="n">d</span>
		<span class="k">print</span> <span class="n">tabstr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bv_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bv_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bv_args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bv_prefix</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generation_probability</span> <span class="c">#&quot;\t&quot;, self.resample_p </span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span> 
				<span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="n">a</span><span class="o">.</span><span class="n">fullprint</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>                 <span class="k">print</span> <span class="n">tabstr</span><span class="p">,</span> <span class="n">a</span>
			
	<span class="c">#def schemestring(self):</span>
		<span class="c">#if self.args == []: # a terminal</span>
			<span class="c">#return str(self.name)</span>
		<span class="c">#else: return &#39;(&#39;+self.name + &#39; &#39;+commalist( [ str(x) for x in self.args], sep1=&#39; &#39;, sep2=&#39; &#39;)+&#39; )&#39;</span>
	
	<span class="c"># NOTE: in the future we may want to change this to do fancy things</span></div>
	<span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pystring</span><span class="p">()</span>
	<span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pystring</span><span class="p">()</span>
	
	<span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
	
	<span class="c">## TODO: overwrite these with something faster</span>
	<span class="c"># hash trees. This just converts to string -- maybe too slow?</span>
	<span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		
		<span class="c"># An attempt to speed things up -- not so great!</span>
		<span class="c">#hsh = self.ruleid</span>
		<span class="c">#if self.args is not None:</span>
			<span class="c">#for a in filter(isFunctionNode, self.args):</span>
				<span class="c">#hsh = hsh ^ hash(a)</span>
		<span class="c">#return hsh</span>
		
		<span class="c"># normal string hash -- faster?</span>
		<span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
		
		<span class="c"># use a quicker string hash		</span>
		<span class="c">#return hash(self.quickstring())</span>
		
		
	<span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
	
	<span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
	
<div class="viewcode-block" id="FunctionNode.log_probability"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.log_probability">[docs]</a>	<span class="k">def</span> <span class="nf">log_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Compute the log probability of a tree</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generation_probability</span> <span class="c"># the probability of my rule</span>
		
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> 
			<span class="n">lp</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">log_probability</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">()</span> <span class="p">])</span>
		<span class="k">return</span> <span class="n">lp</span>
	</div>
<div class="viewcode-block" id="FunctionNode.subnodes"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.subnodes">[docs]</a>	<span class="k">def</span> <span class="nf">subnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Return all subnodes -- no iterator.</span>
<span class="sd">			Useful for modifying</span>
<span class="sd">			</span>
<span class="sd">			NOTE: If you want iterate using the grammar, use Grammar.iterate_subnodes</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
		</div>
<div class="viewcode-block" id="FunctionNode.argFunctionNodes"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.argFunctionNodes">[docs]</a>	<span class="k">def</span> <span class="nf">argFunctionNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Yield FunctionNode immediately below</span>
<span class="sd">			Also handles args is None, so we don&#39;t have to check constantly</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="c"># TODO: In python 3, use yeild from</span>
			<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">isFunctionNode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
				<span class="k">yield</span> <span class="n">n</span>
		</div>
	<span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Iterater for subnodes. </span>
<span class="sd">			NOTE: This will NOT work if you modify the tree. Then all goes to hell. </span>
<span class="sd">			      If the tree must be modified, use self.subnodes()</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">yield</span> <span class="bp">self</span>
		
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">():</span>
				<span class="k">for</span> <span class="n">ssn</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span> <span class="k">yield</span> <span class="n">ssn</span>
	
<div class="viewcode-block" id="FunctionNode.iterdepth"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.iterdepth">[docs]</a>	<span class="k">def</span> <span class="nf">iterdepth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Iterate subnodes, yielding node and depth</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">yield</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">():</span>
				<span class="k">for</span> <span class="n">ssn</span><span class="p">,</span><span class="n">dd</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">iterdepth</span><span class="p">():</span> <span class="k">yield</span> <span class="p">(</span><span class="n">ssn</span><span class="p">,</span><span class="n">dd</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FunctionNode.all_leaves"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.all_leaves">[docs]</a>	<span class="k">def</span> <span class="nf">all_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)):</span> <span class="c"># loop through kids</span>
				<span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
					<span class="k">for</span> <span class="n">ssn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">all_leaves</span><span class="p">():</span>
						<span class="k">yield</span> <span class="n">ssn</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="FunctionNode.string_below"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.string_below">[docs]</a>	<span class="k">def</span> <span class="nf">string_below</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot; &quot;</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_leaves</span><span class="p">()))</span>
	</div>
<div class="viewcode-block" id="FunctionNode.fix_bound_variables"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.fix_bound_variables">[docs]</a>	<span class="k">def</span> <span class="nf">fix_bound_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Fix the naming scheme of bound variables. This happens if we promote or demote some nodes</span>
<span class="sd">			via insert/delete</span>
<span class="sd">			</span>
<span class="sd">			d - current depth</span>
<span class="sd">			rename - a dictionary to store how we should rename</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">rename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">rename</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
				
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">islambda</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span> 
				<span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
				
				<span class="n">newname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bv_prefix</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
					
				<span class="c"># And rename this below</span>
				<span class="n">rename</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">newname</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">bv_name</span> <span class="o">=</span> <span class="n">newname</span>
			<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">rename</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">rename</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
		
		<span class="c"># and recurse</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">():</span>
			
			<span class="c">#print &quot;\t\tRENAMING&quot;, k, k.bv_prefix, rename</span>
			<span class="n">k</span><span class="o">.</span><span class="n">fix_bound_variables</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">rename</span><span class="p">)</span>
			

	<span class="c">############################################################</span>
	<span class="c">## Derived functions that build on the above core</span>
	<span class="c">############################################################</span>
	</div>
<div class="viewcode-block" id="FunctionNode.contains_function"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.contains_function">[docs]</a>	<span class="k">def</span> <span class="nf">contains_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Check if this contains x as function below</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
		<span class="k">return</span> <span class="bp">False</span>
	</div>
<div class="viewcode-block" id="FunctionNode.count_nodes"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.count_nodes">[docs]</a>	<span class="k">def</span> <span class="nf">count_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_subnodes</span><span class="p">()</span></div>
<div class="viewcode-block" id="FunctionNode.count_subnodes"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.count_subnodes">[docs]</a>	<span class="k">def</span> <span class="nf">count_subnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> 
			<span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="n">c</span>
	</div>
<div class="viewcode-block" id="FunctionNode.depth"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.depth">[docs]</a>	<span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">depths</span> <span class="o">=</span> <span class="p">[</span> <span class="n">a</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">()</span> <span class="p">]</span> 
		<span class="n">depths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c"># for no function nodes (+1=0)</span>
		<span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">depths</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
	
	<span class="c"># get a description of the input and output types</span>
	<span class="c"># if collapse_terminal then we just map non-FunctionNodes to &quot;TERMINAL&quot;</span></div>
<div class="viewcode-block" id="FunctionNode.type"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.type">[docs]</a>	<span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			The type of a functionNode is defined to be it&#39;s returntype if it&#39;s not a lambda,</span>
<span class="sd">			or the correct (recursive) lambda structure if it is a lambda. For instance (lambda x. lambda y . (and (empty? x) y))</span>
<span class="sd">			is a (SET (BOOL BOOL)), where in types, (A B) is something that takes an A and returns a B</span>
<span class="sd">		&quot;&quot;&quot;</span>
		
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span> <span class="c"># If we don&#39;t have a function call (as in START), just use the type of what&#39;s below</span>
			<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;**** Nameless calls must have exactly 1 arg&quot;</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
		<span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">islambda</span><span class="p">()):</span> 
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c"># figure out what kind of lambda</span>
			<span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bv_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">t</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_type</span><span class="p">,]</span> <span class="o">+</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_args</span><span class="p">)</span> <span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bv_type</span>
				
			<span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">t</span><span class="p">)</span>
		
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		ts = [self.returntype, self.bv_type, self.bv_args]</span>
<span class="sd">		if self.args is not None:</span>
<span class="sd">			for i in range(len(self.args)):</span>
<span class="sd">				if isFunctionNode(self.args[i]):</span>
<span class="sd">					ts.append(self.args[i].returntype)</span>
<span class="sd">				else: </span>
<span class="sd">					ts.append(self.args[i])</span>
<span class="sd">		return ts</span>
<span class="sd">		&quot;&quot;&quot;</span>
		</div>
<div class="viewcode-block" id="FunctionNode.is_replicating"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.is_replicating">[docs]</a>	<span class="k">def</span> <span class="nf">is_replicating</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			A function node is replicating (by definition) if one of its children is of the same type</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">any</span><span class="p">([</span> <span class="n">x</span><span class="o">.</span><span class="n">returntype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">()</span> <span class="p">])</span>
		
</div>
<div class="viewcode-block" id="FunctionNode.is_canonical_order"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.is_canonical_order">[docs]</a>	<span class="k">def</span> <span class="nf">is_canonical_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symmetric_ops</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Takes a set of symmetric ops (plus, minus, times, etc, not divide) and asserts that the LHS ordering is less than the right (to prevent)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
		
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">symmetric_ops</span><span class="p">:</span>
			
			<span class="c"># Then we must check children</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
			
		<span class="c"># Now check the children, whether or not we are symmetrical</span>
		<span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">is_canonical_order</span><span class="p">(</span><span class="n">symmetric_ops</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">])</span>
		</div>
<div class="viewcode-block" id="FunctionNode.proposal_probability_to"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.proposal_probability_to">[docs]</a>	<span class="k">def</span> <span class="nf">proposal_probability_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Proposal probability from self to y</span>
<span class="sd">		</span>
<span class="sd">			TODO: NOT HEAVILY TESTED/DEBUGGED. PLEASE CHECK</span>
<span class="sd">		&quot;&quot;&quot;</span>
		
		<span class="c"># We could do this node:</span>
		<span class="n">pself</span> <span class="o">=</span> <span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>	
		
		<span class="k">if</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">returntype</span><span class="p">):</span>
			
			<span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s">&quot;-inf&quot;</span><span class="p">)</span>
		
		<span class="k">elif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
			
			<span class="c"># if names are not equal (but return types are) we must generate from the return type, using the root node</span>
			<span class="k">return</span> <span class="n">pself</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">log_probability</span><span class="p">()</span> 
		
		<span class="k">else</span><span class="p">:</span>
			<span class="c"># we have the same name and returntype, so we may generate children</span>
			
			<span class="c"># Compute the arguments and see how mismatched we are</span>
			<span class="n">mismatches</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
					<span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span> <span class="n">mismatches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="p">)</span>
			
			<span class="c"># Now act depending on the mismatches</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mismatches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># we are identical below</span>
				
				<span class="c"># We are the same below here, so we can propose to any subnode, which </span>
				<span class="c"># each happens with prob pself</span>
				<span class="k">return</span> <span class="n">logsumexp</span><span class="p">(</span> <span class="p">[</span><span class="n">pself</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">log_probability</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span> <span class="p">)</span>
			
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">mismatches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				
				<span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">mismatches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
				
				<span class="c"># Well if there&#39;s one mismatch, it lies below a or b,</span>
				<span class="c"># so we must propose in a along this subtree</span>
				<span class="n">m</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">+</span> <span class="n">pself</span> <span class="c"># choose uniformly from this subtree, as individual nodes are adjusted later TODO: IM NOT SURE THIS IS RIGHT </span>
				<span class="k">return</span> <span class="n">logsumexp</span><span class="p">([</span><span class="n">m</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">proposal_probability_to</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">,</span> <span class="n">pself</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">log_probability</span><span class="p">()])</span>
			
			<span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">pself</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">log_probability</span><span class="p">()</span> <span class="c"># We have to generate from ourselves</span>
				</div>
<div class="viewcode-block" id="FunctionNode.replace_subnodes"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.replace_subnodes">[docs]</a>	<span class="k">def</span> <span class="nf">replace_subnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">find</span><span class="p">,</span> <span class="n">replace</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Replace subnodes</span>
<span class="sd">			NOTE: NOT THE FASTEST!</span>
<span class="sd">			NOTE: Defaultly only makes copies of replace</span>
<span class="sd">		&quot;&quot;&quot;</span>
		
		<span class="c"># now go through and modify</span>
		<span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">==</span><span class="n">find</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subnodes</span><span class="p">()</span> <span class="p">):</span> <span class="c">#NOTE: must use subnodes since we are modfiying</span>
			<span class="n">g</span><span class="o">.</span><span class="n">setto</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="n">replace</span><span class="p">))</span>
	</div>
<div class="viewcode-block" id="FunctionNode.partial_subtree_root_match"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.partial_subtree_root_match">[docs]</a>	<span class="k">def</span> <span class="nf">partial_subtree_root_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Does y match from my root? </span>
<span class="sd">			</span>
<span class="sd">			A partial tree here is one with some nonterminals (see random_partial_subtree) that</span>
<span class="sd">			are not expanded</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">returntype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
			<span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
		
			<span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span> <span class="k">return</span> <span class="bp">False</span>
		
			<span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">partial_subtree_root_match</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="bp">False</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="bp">False</span> <span class="c"># cannot work!</span>
					
					<span class="c"># neither is a function node</span>
					<span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
				
			<span class="k">return</span> <span class="bp">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c"># else y is a string and we match if y is our returntype</span>
			<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span> 
				</div>
<div class="viewcode-block" id="FunctionNode.partial_subtree_match"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.partial_subtree_match">[docs]</a>	<span class="k">def</span> <span class="nf">partial_subtree_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Does y match anywhere?</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">partial_subtree_root_match</span><span class="p">(</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="bp">True</span>
		
		<span class="k">return</span> <span class="bp">False</span>
	</div>
<div class="viewcode-block" id="FunctionNode.random_partial_subtree"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.random_partial_subtree">[docs]</a>	<span class="k">def</span> <span class="nf">random_partial_subtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">			Generate a random partial subtree of me. So that</span>
<span class="sd">			</span>
<span class="sd">			this: </span>
<span class="sd">				prev_((seven_ if cardinality1_(x) else next_(next_(L_(x)))))</span>
<span class="sd">			yeilds:</span>
<span class="sd">							</span>
<span class="sd">				prev_(WORD)</span>
<span class="sd">				prev_(WORD)</span>
<span class="sd">				prev_((seven_ if cardinality1_(x) else WORD))</span>
<span class="sd">				prev_(WORD)</span>
<span class="sd">				prev_((seven_ if BOOL else next_(next_(L_(SET)))))</span>
<span class="sd">				prev_(WORD)</span>
<span class="sd">				prev_((seven_ if cardinality1_(SET) else next_(WORD)))</span>
<span class="sd">				prev_(WORD)</span>
<span class="sd">				prev_((seven_ if BOOL else next_(WORD)))</span>
<span class="sd">				...</span>
<span class="sd">				</span>
<span class="sd">			We do this because there are waay too many unique subtrees to enumerate, </span>
<span class="sd">			and this allows a nice variety of structures</span>
<span class="sd">			NOTE: Partial here means that we include nonterminals with probability p</span>
<span class="sd">		&quot;&quot;&quot;</span>
		
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		
		<span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">:</span> <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">a</span><span class="o">.</span><span class="n">returntype</span> <span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>            <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">a</span><span class="o">.</span><span class="n">random_partial_subtree</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> <span class="p">)</span>
			<span class="k">else</span><span class="p">:</span> 
				<span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c"># string or something else</span>
				
		<span class="n">ret</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">(</span><span class="n">shallow</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># don&#39;t copy kids</span>
		<span class="n">ret</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">newargs</span>
		
		<span class="k">return</span> <span class="n">ret</span>
		
		</div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">LOTlib 1.0.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../LOTlib.html" >LOTlib</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Steve Piantadosi.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>
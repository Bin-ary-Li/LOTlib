<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LOTlib.FunctionNode &mdash; LOTlib 0.2.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="LOTlib 0.2.0 documentation" href="../../index.html" />
    <link rel="up" title="LOTlib" href="../LOTlib.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">LOTlib 0.2.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../LOTlib.html" accesskey="U">LOTlib</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for LOTlib.FunctionNode</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A function node -- a tree part representing a function and its arguments.</span>

<span class="sd">Also used for PCFG rules, where the arguments are nonterminal symbols.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">graphviz</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="kn">from</span> <span class="nn">LOTlib.Miscellaneous</span> <span class="kn">import</span> <span class="n">None2Empty</span><span class="p">,</span> <span class="n">lambdaTrue</span><span class="p">,</span> <span class="n">Infinity</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">==============================================================================================================</span>
<span class="sd">== Helper functions </span>
<span class="sd">==============================================================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="isFunctionNode"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.isFunctionNode">[docs]</a><span class="k">def</span> <span class="nf">isFunctionNode</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c"># just because this is nicer, and allows us to map, etc.</span>
    <span class="sd">&quot;&quot;&quot;Returns true if *x* is of type FunctionNode.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">FunctionNode</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="cleanFunctionNodeString"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.cleanFunctionNodeString">[docs]</a><span class="k">def</span> <span class="nf">cleanFunctionNodeString</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Makes FunctionNode strings easier to read.&quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;lambda&quot;</span><span class="p">,</span> <span class="s">u&quot;</span><span class="se">\u03BB</span><span class="s">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c"># make lambdas the single char</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>  <span class="c"># remove underscores</span>
    <span class="k">return</span> <span class="n">s</span>

</div>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def DOTstring_old(x, d=0, bv_names=dict()):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Outputs a string in (lambda (x) (+ x 3)) format.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    if d == 0:</span>
<span class="sd">        return &#39;digraph g {&#39;+DOTstring_old(x,d=1)+&#39;\n}&#39;</span>

<span class="sd">    if isinstance(x, str):</span>
<span class="sd">        return x</span>
<span class="sd">    elif isFunctionNode(x):</span>

<span class="sd">        name = x.name</span>
<span class="sd">        if isinstance(x, BVUseFunctionNode):</span>
<span class="sd">            name = bv_names.get(x.name, x.name)</span>

<span class="sd">        if x.args is None:</span>
<span class="sd">            s = name+&#39;;\n&#39;</span>
<span class="sd">            return name</span>
<span class="sd">        else:</span>
<span class="sd">            if x.args is None:</span>
<span class="sd">                return name</span>
<span class="sd">            elif isinstance(x, BVAddFunctionNode):</span>
<span class="sd">                assert name is &#39;lambda&#39;</span>
<span class="sd">                s = name + &#39;;\n\t&#39;</span>
<span class="sd">                s = s+x.added_rule.name+&#39;;\n\t&#39;</span>
<span class="sd">                s = s+map(lambda a: DOTstring_old(a, d+1, bv_names=bv_names), x.args) + &#39;;\n\t&#39;</span>
<span class="sd">                return s</span>
<span class="sd">                # return &quot;(%s (%s) %s)&quot; % (name, x.added_rule.name, map(lambda a: DOTstring(a,d+1,bv_names=bv_names), x.args))</span>
<span class="sd">            else:</span>
<span class="sd">                s = name + &#39;;\n\t&#39;</span>
<span class="sd">                s = s+map(lambda a: DOTstring_old(a, d+1, bv_names=bv_names), x.args) + &#39;;\n\t&#39;</span>
<span class="sd">                return s</span>
<span class="sd">                # return &quot;(%s %s)&quot; % (name, map(lambda a: DOTstring(a,d+1,bv_names=bv_names), x.args))</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">==============================================================================================================================================</span>
<span class="sd">== String casting functions</span>
<span class="sd">==============================================================================================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="schemestring"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.schemestring">[docs]</a><span class="k">def</span> <span class="nf">schemestring</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Outputs a scheme string in (lambda (x) (+ x 3)) format.</span>

<span class="sd">    Args:</span>
<span class="sd">        bv_names: A dictionary from the uuids to nicer names.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">bv_names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">bv_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BVUseFunctionNode</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">bv_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BVAddFunctionNode</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="s">&#39;lambda&#39;</span>
                <span class="k">return</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s"> (</span><span class="si">%s</span><span class="s">) </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">schemestring</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">schemestring</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="pystring"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.pystring">[docs]</a><span class="k">def</span> <span class="nf">pystring</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Output a string that can be evaluated by python; gives bound variables names based on their depth.</span>

<span class="sd">    Args:</span>
<span class="sd">        bv_names: A dictionary from the uuids to nicer names.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span> 
        <span class="k">return</span> <span class="n">x</span> 
    <span class="k">elif</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">bv_names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">bv_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>    
        
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;if_&quot;</span><span class="p">:</span> <span class="c"># this gets translated</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;if_ requires 3 arguments!&quot;</span>
            <span class="c"># This converts from scheme (if bool s t) to python (s if bool else t)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">pystring</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">pystring</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">pystring</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">)</span>
            <span class="k">return</span> <span class="s">&#39;( </span><span class="si">%s</span><span class="s"> if </span><span class="si">%s</span><span class="s"> else </span><span class="si">%s</span><span class="s"> )&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Null names must have exactly 1 argument&quot;</span>
            <span class="k">return</span> <span class="n">pystring</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;apply_&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Apply requires exactly 2 arguments&quot;</span>
            <span class="c">#print &quot;&gt;&gt;&gt;&gt;&quot;, self.args</span>
            <span class="k">return</span> <span class="s">&#39;( </span><span class="si">%s</span><span class="s"> )( </span><span class="si">%s</span><span class="s"> )&#39;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pystring</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;or_sc_&quot;</span><span class="p">:</span> <span class="c"># short-circuit or</span>
            <span class="k">return</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="s">&#39; or &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pystring</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;and_sc_&quot;</span><span class="p">:</span> <span class="c"># short-circuit and</span>
            <span class="k">return</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="s">&#39; and &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pystring</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;lambda&#39;</span><span class="p">:</span>
            <span class="c"># On a lambda, we must add the introduced bv, and then remove it again afterwards</span>
            
            <span class="n">bvn</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BVAddFunctionNode</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">added_rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">bvn</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">bv_prefix</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">bv_names</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">bvn</span>
            
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="s">&#39;lambda </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">bvn</span><span class="p">,</span> <span class="n">pystring</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">)</span> <span class="p">)</span>
            
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">added_rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">bv_names</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                
            <span class="k">return</span> <span class="n">ret</span>  
        <span class="k">else</span><span class="p">:</span>
            
            <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BVUseFunctionNode</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">bv_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> 
        
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>             
                <span class="k">return</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name</span><span class="o">+</span><span class="s">&#39;(&#39;</span><span class="o">+</span><span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">pystring</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">))</span><span class="o">+</span><span class="s">&#39;)&#39;</span>

</div>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">==============================================================================================================</span>
<span class="sd">== FunctionNode main class</span>
<span class="sd">==============================================================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="FunctionNode"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode">[docs]</a><span class="k">class</span> <span class="nc">FunctionNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;FunctionNode main class.</span>

<span class="sd">    Args:</span>
<span class="sd">        returntype: The return type of the FunctionNode.</span>
<span class="sd">        name: The name of the function.</span>
<span class="sd">        args: Arguments of the function</span>
<span class="sd">        generation_probability: Unnormalized generation probability.</span>
<span class="sd">        resample_p: The probability of choosing this node in resampling. Takes any number &gt;0 (all are</span>
<span class="sd">            normalized)</span>
<span class="sd">        rule: The rule that was used in generating the FunctionNode</span>
<span class="sd">        bv: Stores the actual *rule* that was added (so that we can re-add it when we loop through the tree).</span>

<span class="sd">    Note:</span>
<span class="sd">        If a node has [ None ] as args, it is treated as a thunk</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">returntype</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">generation_probability</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">resample_p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">a_args</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;applylambda&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span> <span class="c"># Let&#39;s not support any applylambda for now</span>
    
<div class="viewcode-block" id="FunctionNode.setto"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.setto">[docs]</a>    <span class="k">def</span> <span class="nf">setto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Makes all the parts the same as q, not copies.</span>

<span class="sd">        Note that this sets the parent of q to my current parent!</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>        <span class="c"># preserve my parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">__dict__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">__class__</span>    <span class="c"># to update in case q is a different subtype of FunctionNode.</span>
                                        <span class="c"># NOTE: Setting __class__ is not a recommended thing to do.</span>

        <span class="c"># and we must fix the kid refs. Everything else should be right.</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">():</span>
            <span class="n">a</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">old_parent</span>
</div>
<div class="viewcode-block" id="FunctionNode.__copy__"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.__copy__">[docs]</a>    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shallow</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy a function node.</span>

<span class="sd">        Args:</span>
<span class="sd">            *shallow* - if True, this does not copy the children (self.to points to the same as what we return)</span>
<span class="sd">        Note:</span>
<span class="sd">            The rule is NOT deeply copied (regardless of shallow)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">FunctionNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span>
                          <span class="n">generation_probability</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generation_probability</span><span class="p">,</span>
                          <span class="n">resample_p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resample_p</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">shallow</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fn</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>

        <span class="c"># and update </span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fn</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">():</span>
            <span class="n">a</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">fn</span> 

        <span class="k">return</span> <span class="n">fn</span> 
        </div>
<div class="viewcode-block" id="FunctionNode.is_nonfunction"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.is_nonfunction">[docs]</a>    <span class="k">def</span> <span class="nf">is_nonfunction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if the Node contains no function arguments, False otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FunctionNode.is_function"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.is_function">[docs]</a>    <span class="k">def</span> <span class="nf">is_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if the Node contains function arguments, False otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_nonfunction</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="FunctionNode.is_leaf"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.is_leaf">[docs]</a>    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if none of the kids are FunctionNodes, meaning this should be considered a &quot;leaf&quot;.</span>

<span class="sd">        Note:</span>
<span class="sd">            A leaf may be a function, but its args are specified in the grammar.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="FunctionNode.is_root"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.is_root">[docs]</a>    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="bp">None</span>
    </div>
<div class="viewcode-block" id="FunctionNode.check_parent_refs"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.check_parent_refs">[docs]</a>    <span class="k">def</span> <span class="nf">check_parent_refs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recurse through the tree and ensure that the parent refs are good.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">check_parent_refs</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">True</span><span class="p">):</span>
                <span class="k">print</span> <span class="s">&quot;Bad parent reference at </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="n">t</span><span class="o">.</span><span class="n">name</span>
                <span class="k">print</span> <span class="s">&quot;If it prints, the full string is </span><span class="si">%s</span><span class="s">, a subnode of </span><span class="si">%s</span><span class="s">, whose parent is </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">False</span>
            
        <span class="k">return</span> <span class="bp">True</span>
    </div>
<div class="viewcode-block" id="FunctionNode.check_generation_probabilities"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.check_generation_probabilities">[docs]</a>    <span class="k">def</span> <span class="nf">check_generation_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check this node&#39;s generation probabilities.</span>

<span class="sd">        Note:</span>
<span class="sd">            The can only be called on root -- no bvs allowed unless they are introduced,</span>
<span class="sd">            or else grammar.recompute_generation_probabilities will not work right.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># and check the generation probabilities -- that these are set correctly</span>
        <span class="n">gps</span>  <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">generation_probability</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">grammar</span><span class="o">.</span><span class="n">recompute_generation_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c"># re-check these</span>
        <span class="n">gps2</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">generation_probability</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gps</span><span class="p">,</span> <span class="n">gps2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subnodes</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;# Wrong generation probabilities </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> for </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">False</span>
            
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="FunctionNode.as_list"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.as_list">[docs]</a>    <span class="k">def</span> <span class="nf">as_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list representation of the FunctionNode with function/self.name as the first element.</span>

<span class="sd">        This function is subclassed so by BVAdd and BVUse so that those handle other cases</span>

<span class="sd">        Args:</span>
<span class="sd">            d: An optional argument that keeps track of how far down the tree we are</span>
<span class="sd">            bv_names: A dictionary keeping track of the names of bound variables (keys = UUIDs,</span>
<span class="sd">                values = names)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># the tree should be represented as the empty set if the function node has no name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            
        <span class="c"># and we&#39;re now ready to loop over the function node&#39;s arguments</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">as_list</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">x</span>
        
    </div>
<div class="viewcode-block" id="FunctionNode.quickstring"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.quickstring">[docs]</a>    <span class="k">def</span> <span class="nf">quickstring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A (maybe??) faster string function used for hashing.</span>

<span class="sd">        Doesn&#39;t handle any details and is meant to just be quick.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c"># simple call</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Don&#39;t use + to concatenate strings.</span>
            <span class="k">return</span> <span class="s">&#39;{} {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)))</span>
</div>
<div class="viewcode-block" id="FunctionNode.fullprint"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.fullprint">[docs]</a>    <span class="k">def</span> <span class="nf">fullprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A handy printer for debugging&quot;&quot;&quot;</span>
        <span class="n">tabstr</span> <span class="o">=</span> <span class="s">&quot;  .  &quot;</span> <span class="o">*</span> <span class="n">d</span>
        <span class="k">print</span> <span class="n">tabstr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> \
            <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generation_probability</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">fullprint</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">print</span> <span class="n">tabstr</span><span class="p">,</span> <span class="n">a</span>
</div>
<div class="viewcode-block" id="FunctionNode.liststring"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.liststring">[docs]</a>    <span class="k">def</span> <span class="nf">liststring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="s">&quot;cons_&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This &quot;evals&quot; cons_ so that we can conveniently build lists (of lists) without having to eval.</span>

<span class="sd">        Mainly useful for combinatory logic, or &quot;pure&quot; trees</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">cons</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">liststring</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;FunctionNode must only use cons to call liststring!&quot;</span>
</div>
<div class="viewcode-block" id="FunctionNode.make_dot"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.make_dot">[docs]</a>    <span class="k">def</span> <span class="nf">make_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="p">,</span> <span class="n">parent_n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setup self.dot as a graphviz / DOT format graph for this FunctionNode.</span>

<span class="sd">        We proceed through each node in the graph, creating unique names for each child by concat&#39;ing</span>
<span class="sd">        child int to the parent string. E.g. node &#39;01&#39; may have children &#39;010&#39;, &#39;011&#39;, &#39;012&#39;, ...</span>

<span class="sd">        This is done because in DOT format we need to enumerate edges between nodes, so we need a unique</span>
<span class="sd">        string name to draw edges. For example, node name &#39;plus_&#39; will be ambiguous for &#39;(plus_ (plus_ ...&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            ls (list): List of items... the first item in the list is either the operator, or the only</span>
<span class="sd">                thing in the list.</span>
<span class="sd">            n (str): Name of this FunctionNode.</span>
<span class="sd">            parent_n (str): Name of parent FunctionNode.</span>

<span class="sd">        Requires:</span>
<span class="sd">            graphviz: install graphviz from www.graphviz.org, then enter::  $ pip install graphviz</span>

<span class="sd">        References:</span>
<span class="sd">            en.wikipedia.org/wiki/DOT_(graph_description_language)</span>
<span class="sd">            pypi.python.org/pypi/graphviz</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Initialize</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;dot&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">=</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="n">comment</span><span class="o">=</span><span class="s">&#39;The DOT Graph&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ls</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_list</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">this_n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span>

        <span class="c"># handle items like &#39;bound=100&#39; (are there others that will be like this?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">parent_n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">parent_n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">d</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">this_n</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">ls</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="s">&#39;square&#39;</span><span class="p">)</span>
                <span class="n">d</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">parent_n</span><span class="p">,</span> <span class="n">this_n</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s">&#39;dotted&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c"># node for this FunctionNode</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">this_n</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">shape</span><span class="o">=</span><span class="s">&#39;plaintext&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">parent_n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">parent_n</span><span class="p">,</span> <span class="n">this_n</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s">&#39;solid&#39;</span><span class="p">)</span>
            <span class="c"># children FunctionNodes...</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ls</span><span class="p">)):</span>
                    <span class="c"># Recursive call</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">make_dot</span><span class="p">(</span><span class="n">ls</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">this_n</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">parent_n</span><span class="o">=</span><span class="n">this_n</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FunctionNode.dot_string"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.dot_string">[docs]</a>    <span class="k">def</span> <span class="nf">dot_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return DOT graph format string; see make_dot docstring.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;dot&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_dot</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="o">.</span><span class="n">source</span>

    <span class="c"># NOTE: in the future we may want to change this to do fancy things</span></div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pystring</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pystring</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="FunctionNode.__eq__"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if two FunctionNodes are equal.</span>

<span class="sd">        This is actually a little subtle due to bound variables.</span>

<span class="sd">        In (lambda (x) x) and (lambda (y) y) will be equal (since they map to identical strings via</span>
<span class="sd">        pystring), even though the nodes below x and y will not themselves be equal. This is because</span>
<span class="sd">        pystring(x) and pystring(y) will not know where these came from and will just cmopare the uuids.</span>

<span class="sd">        But pystring on the lambda keeps track of where bound variables were introduced.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pystring</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">pystring</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c">## TODO: overwrite these with something faster</span>
    <span class="c"># hash trees. This just converts to string -- maybe too slow?</span></div>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c"># An attempt to speed things up -- not so great!</span>
        <span class="c">#hsh = self.ruleid</span>
        <span class="c">#if self.args is not None:</span>
            <span class="c">#for a in filter(isFunctionNode, self.args):</span>
                <span class="c">#hsh = hsh ^ hash(a)</span>
        <span class="c">#return hsh</span>

        <span class="c"># normal string hash -- faster?</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c"># use a quicker string hash</span>
        <span class="c">#return hash(self.quickstring())</span>

    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

<div class="viewcode-block" id="FunctionNode.log_probability"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.log_probability">[docs]</a>    <span class="k">def</span> <span class="nf">log_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the log probability of a tree.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generation_probability</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">log_probability</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">()])</span>
</div>
<div class="viewcode-block" id="FunctionNode.subnodes"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.subnodes">[docs]</a>    <span class="k">def</span> <span class="nf">subnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all subnodes -- no iterator.</span>

<span class="sd">        Useful for modifying</span>

<span class="sd">        Note:</span>
<span class="sd">            If you want iterate using the grammar, use Grammar.iterate_subnodes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="FunctionNode.argFunctionNodes"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.argFunctionNodes">[docs]</a>    <span class="k">def</span> <span class="nf">argFunctionNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield FunctionNode immediately below.</span>

<span class="sd">        Also handles args is None, so we don&#39;t have to check constantly</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># TODO: In python 3, use yeild from</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">isFunctionNode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">n</span>
</div>
<div class="viewcode-block" id="FunctionNode.is_terminal"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.is_terminal">[docs]</a>    <span class="k">def</span> <span class="nf">is_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A FunctionNode is considered a &quot;terminal&quot; if it has no FunctionNodes below.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">isFunctionNode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
</div>
<div class="viewcode-block" id="FunctionNode.__iter__"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterater for subnodes.</span>

<span class="sd">        Note:</span>
<span class="sd">            This will NOT work if you modify the tree. Then all goes to hell.</span>
<span class="sd">            If the tree must be modified, use self.subnodes().</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">ssn</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">ssn</span>
</div>
<div class="viewcode-block" id="FunctionNode.iterdepth"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.iterdepth">[docs]</a>    <span class="k">def</span> <span class="nf">iterdepth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterates subnodes, yielding node and depth.&quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">ssn</span><span class="p">,</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">iterdepth</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">ssn</span><span class="p">,</span> <span class="n">dd</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FunctionNode.all_leaves"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.all_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">all_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a generator for all leaves of the subtree rooted at the instantiated FunctionNode.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)):</span>  <span class="c"># loop through kids</span>
                <span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">ssn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">all_leaves</span><span class="p">():</span>
                        <span class="k">yield</span> <span class="n">ssn</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="FunctionNode.string_below"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.string_below">[docs]</a>    <span class="k">def</span> <span class="nf">string_below</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot; &quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The string of terminals (leaves) below the current FunctionNode in the parse tree.</span>

<span class="sd">        Args:</span>
<span class="sd">            sep: is the delimiter between terminals. E.g. sep=&quot;,&quot; =&gt; &quot;the,fuzzy,cat&quot;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_leaves</span><span class="p">()))</span>

    <span class="c">############################################################</span>
    <span class="c">## Derived functions that build on the above core</span>
    <span class="c">############################################################</span>
</div>
<div class="viewcode-block" id="FunctionNode.contains_function"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.contains_function">[docs]</a>    <span class="k">def</span> <span class="nf">contains_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if the FunctionNode contains x as function below.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
            </div>
<div class="viewcode-block" id="FunctionNode.up_to"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.up_to">[docs]</a>    <span class="k">def</span> <span class="nf">up_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield all nodes going up to &quot;to&quot;. If &quot;to&quot; is None, we go until the root (default).&quot;&quot;&quot;</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">to</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ptr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">ptr</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="n">parent</span>
</div>
<div class="viewcode-block" id="FunctionNode.count_nodes"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.count_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">count_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the subnode count.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_subnodes</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="FunctionNode.count_subnodes"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.count_subnodes">[docs]</a>    <span class="k">def</span> <span class="nf">count_subnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="n">lambdaTrue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the subnode count.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="FunctionNode.depth"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.depth">[docs]</a>    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the depth of the tree (how many embeddings below).&quot;&quot;&quot;</span>
        <span class="n">depths</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">()]</span>
        <span class="n">depths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># for no function nodes (+1=0)</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">depths</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</div>
<div class="viewcode-block" id="FunctionNode.sample_node_normalizer"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.sample_node_normalizer">[docs]</a>    <span class="k">def</span> <span class="nf">sample_node_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="n">lambdaTrue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute Z to be the sum of all subnodes&#39; resample_p.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span> <span class="n">t</span><span class="o">.</span><span class="n">resample_p</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="bp">self</span><span class="p">)])</span>
    </div>
<div class="viewcode-block" id="FunctionNode.sample_subnode"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.sample_subnode">[docs]</a>    <span class="k">def</span> <span class="nf">sample_subnode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="n">lambdaTrue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sample a subnode at random.</span>

<span class="sd">        We return a sampled tree and the log probability of sampling it</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_node_normalizer</span><span class="p">(</span><span class="n">predicate</span><span class="o">=</span><span class="n">predicate</span><span class="p">)</span> <span class="c"># the total probability</span>
        
        <span class="k">if</span> <span class="n">Z</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="n">Infinity</span> <span class="c"># nothing works!</span>
        
        <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="n">Z</span> <span class="c"># now select a random number (giving a random node)</span>
        
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">resample_p</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">log</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">resample_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">Z</span><span class="p">)]</span>

    <span class="c"># get a description of the input and output types</span>
    <span class="c"># if collapse_terminal then we just map non-FunctionNodes to &quot;TERMINAL&quot;</span></div>
<div class="viewcode-block" id="FunctionNode.type"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The type of a FunctionNode is defined to be its returntype if it&#39;s not a lambda, or is defined</span>
<span class="sd">        to be the correct (recursive) lambda structure if it is a lambda.</span>

<span class="sd">        For instance (lambda x. lambda y . (and (empty? x) y))</span>
<span class="sd">        is a (SET (BOOL BOOL)), where in types, (A B) is something that takes an A and returns a B</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>  <span class="c"># If we don&#39;t have a function call (as in START), just use the type of what&#39;s below</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;**** Nameless calls must have exactly 1 arg&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BVAddFunctionNode</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># figure out what kind of lambda</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">nt</span><span class="p">,]</span> <span class="o">+</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">self</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">to</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">nt</span>

            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">t</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FunctionNode.is_canonical_order"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.is_canonical_order">[docs]</a>    <span class="k">def</span> <span class="nf">is_canonical_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symmetric_ops</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take a set of symmetric (commutative) ops (plus, minus, times, etc, not divide) and asserts that</span>
<span class="sd">            the LHS ordering is less than the right (to prevent)</span>

<span class="sd">        This is useful for removing duplicates of nodes. For instance,</span>

<span class="sd">                AND(X, OR(Y,Z))</span>

<span class="sd">        is logically the same as</span>

<span class="sd">                AND(OR(Y,Z), X)</span>

<span class="sd">        This function essentially checks if the tree is in sorted (alphbetical)</span>
<span class="sd">        order, but only for functions whose name is in symmetric_ops.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">symmetric_ops</span><span class="p">:</span>

            <span class="c"># Then we must check children</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Now check the children, whether or not we are symmetrical</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">is_canonical_order</span><span class="p">(</span><span class="n">symmetric_ops</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">()</span> <span class="p">])</span>
</div>
<div class="viewcode-block" id="FunctionNode.replace_subnodes"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.replace_subnodes">[docs]</a>    <span class="k">def</span> <span class="nf">replace_subnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">replace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set all nodes satifying predicate to a copy of replace.</span>

<span class="sd">        Note: we must fix probabilities after this since they may not be right--we can copy into a place</span>
<span class="sd">            where a lambda is defined.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># now go through and modify</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subnodes</span><span class="p">()):</span>  <span class="c"># NOTE: must use subnodes since we are modfiying</span>
            <span class="n">n</span><span class="o">.</span><span class="n">setto</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="n">replace</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="FunctionNode.partial_subtree_root_match"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.partial_subtree_root_match">[docs]</a>    <span class="k">def</span> <span class="nf">partial_subtree_root_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Does *y* match from my root?</span>

<span class="sd">        A partial tree here is one with some nonterminals (see random_partial_subtree) that</span>
<span class="sd">        are not expanded</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">returntype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">partial_subtree_root_match</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">False</span>  <span class="c"># cannot work!</span>

                    <span class="c"># neither is a function node</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">False</span>

            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># else y is a string and we match if y is our returntype</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span>
</div>
<div class="viewcode-block" id="FunctionNode.partial_subtree_match"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.partial_subtree_match">[docs]</a>    <span class="k">def</span> <span class="nf">partial_subtree_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Does *y* match a subtree anywhere?&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">partial_subtree_root_match</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="FunctionNode.random_partial_subtree"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.FunctionNode.random_partial_subtree">[docs]</a>    <span class="k">def</span> <span class="nf">random_partial_subtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a random partial subtree of me.</span>


<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt; prev_((seven_ if cardinality1_(x) else next_(next_(L_(x)))))</span>
<span class="sd">            prev_(WORD)</span>
<span class="sd">            prev_(WORD)</span>
<span class="sd">            prev_((seven_ if cardinality1_(x) else WORD))</span>
<span class="sd">            prev_(WORD)</span>
<span class="sd">            prev_((seven_ if BOOL else next_(next_(L_(SET)))))</span>
<span class="sd">            prev_(WORD)</span>
<span class="sd">            prev_((seven_ if cardinality1_(SET) else next_(WORD)))</span>
<span class="sd">            prev_(WORD)</span>
<span class="sd">            prev_((seven_ if BOOL else next_(WORD)))</span>
<span class="sd">            ...</span>

<span class="sd">        We do this because there are waay too many unique subtrees to enumerate, and this allows a nice</span>
<span class="sd">        variety of structures</span>

<span class="sd">        Note:</span>
<span class="sd">            Partial here means that we include nonterminals with probability p</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">:</span>
                    <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">returntype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">random_partial_subtree</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c"># string or something else</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">(</span><span class="n">shallow</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># don&#39;t copy kids</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">newargs</span>

        <span class="k">return</span> <span class="n">ret</span>
</div></div>
<div class="viewcode-block" id="BVAddFunctionNode"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.BVAddFunctionNode">[docs]</a><span class="k">class</span> <span class="nc">BVAddFunctionNode</span><span class="p">(</span><span class="n">FunctionNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">returntype</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
                 <span class="n">generation_probability</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">resample_p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">a_args</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">added_rule</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">FunctionNode</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">returntype</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
                              <span class="n">generation_probability</span><span class="p">,</span> <span class="n">resample_p</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">a_args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span> <span class="o">=</span> <span class="n">added_rule</span>

<div class="viewcode-block" id="BVAddFunctionNode.__copy__"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.BVAddFunctionNode.__copy__">[docs]</a>    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shallow</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy a function node.</span>
<span class="sd">                </span>
<span class="sd">        Note:</span>
<span class="sd">            The rule is NOT deeply copied (regardless of shallow)</span>

<span class="sd">        Args:</span>
<span class="sd">            shallow: if True, this does not copy the children (self.to points to the same as what we return)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">BVAddFunctionNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span>
                          <span class="n">generation_probability</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generation_probability</span><span class="p">,</span>
                          <span class="n">resample_p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resample_p</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="p">,</span> <span class="n">a_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a_args</span><span class="p">,</span> <span class="n">added_rule</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">shallow</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fn</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fn</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">():</span>
            <span class="n">a</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">fn</span>

        <span class="k">return</span> <span class="n">fn</span>

    </div>
<div class="viewcode-block" id="BVAddFunctionNode.as_list"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.BVAddFunctionNode.as_list">[docs]</a>    <span class="k">def</span> <span class="nf">as_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list representation of the FunctionNode with function/self.name as the first element.</span>

<span class="sd">        Args:</span>
<span class="sd">            d: An optional argument that keeps track of how far down the tree we are.</span>
<span class="sd">            bv_names: A dictionary keeping track of the names of bound variables (keys = UUIDs,</span>
<span class="sd">            values = names).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># initialize the bv_names variable if it&#39;s not defined</span>
        <span class="k">if</span> <span class="n">bv_names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">bv_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>    
        
        <span class="c"># Since this is a lambda, we should add an item to the bv_names dictionary</span>
        <span class="c"># print &quot;We are a lambda node...&quot;, self.name</span>
        <span class="n">bvn</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">bvn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">bv_prefix</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">bv_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">bvn</span>
        
        <span class="c"># Call super now that bv_names has been defined</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">FunctionNode</span><span class="o">.</span><span class="n">as_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">bv_names</span><span class="p">)</span>
        
        <span class="c"># afterwards, we should remove the BV name from the bv_names dictionary</span>
        <span class="c"># TODO: do we really need this?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">bv_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">added_rule</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
 
        <span class="c"># print &quot;\tand dictionary &quot;, bv_names, &quot; returns: &quot;, x</span>
        <span class="k">return</span> <span class="n">x</span>

</div></div>
<div class="viewcode-block" id="BVUseFunctionNode"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.BVUseFunctionNode">[docs]</a><span class="k">class</span> <span class="nc">BVUseFunctionNode</span><span class="p">(</span><span class="n">FunctionNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">returntype</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
                 <span class="n">generation_probability</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">resample_p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">a_args</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bv_prefix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">FunctionNode</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">returntype</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
                              <span class="n">generation_probability</span><span class="p">,</span> <span class="n">resample_p</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">a_args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bv_prefix</span> <span class="o">=</span> <span class="n">bv_prefix</span>

<div class="viewcode-block" id="BVUseFunctionNode.as_list"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.BVUseFunctionNode.as_list">[docs]</a>    <span class="k">def</span> <span class="nf">as_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list representation of the FunctionNode with function/self.name as the first element.</span>

<span class="sd">        Args:</span>
<span class="sd">            d: An optional argument that keeps track of how far down the tree we are</span>
<span class="sd">            bv_names: A dictionary keeping track of the names of bound variables (keys = UUIDs,</span>
<span class="sd">            values = names)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># the tree should be represented as the empty set if the function node has no name</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">bv_names</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">bv_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]]</span>

        <span class="c"># and we&#39;re now ready to loop over the function node&#39;s arguments</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">as_list</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bv_names</span><span class="o">=</span><span class="n">bv_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">isFunctionNode</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
 
        <span class="k">return</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="BVUseFunctionNode.__copy__"><a class="viewcode-back" href="../../LOTlib.html#LOTlib.FunctionNode.BVUseFunctionNode.__copy__">[docs]</a>    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shallow</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy a function node.</span>
<span class="sd">                </span>
<span class="sd">        Note:</span>
<span class="sd">            The rule is NOT deeply copied (regardless of shallow)</span>

<span class="sd">        Args:</span>
<span class="sd">            shallow: if True, this does not copy the children (self.to points to the same as what we return)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">BVUseFunctionNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">returntype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span>
                               <span class="n">generation_probability</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generation_probability</span><span class="p">,</span>
                               <span class="n">resample_p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resample_p</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="p">,</span> <span class="n">a_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a_args</span><span class="p">,</span>
                               <span class="n">bv_prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_prefix</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">shallow</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fn</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fn</span><span class="o">.</span><span class="n">argFunctionNodes</span><span class="p">():</span>
            <span class="n">a</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">fn</span>

        <span class="k">return</span> <span class="n">fn</span>
</pre></div></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">LOTlib 0.2.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../LOTlib.html" >LOTlib</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Steven Piantadosi.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>
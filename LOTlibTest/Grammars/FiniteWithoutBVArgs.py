"""
	A small finite grammar with bound variables that don't have any args.
"""


from LOTlib.Grammar import Grammar
import math

g = Grammar()

g.add_rule("START", "S", ["NP", "VP"], 1.0)
g.add_rule("NP", "NP", ["det", "N"], 1.0)
g.add_rule("VP", "VP", ["V", "NP"], 1.0)
g.add_rule("VP", "AGE", ["is", "AGE", "years old"], 1.0)
g.add_rule("det", "the", None, 1.0)
g.add_rule("N", "cat", None, 1.0)
g.add_rule("N", "human", None, 1.0)
g.add_rule("V", "likes", None, 1.0)
g.add_rule("V", "kills", None, 1.0)
g.add_rule("V", "eats", None, 1.0)
g.add_rule('AGE', '', ['INT'], 1.0,  bv_type='INT', bv_args=None, bv_prefix='a') # NOTE: Bound variable probability rules are defaultly 10.0!!!!!!!!!
g.add_rule('INT', '20', None, 1.0)
g.add_rule('INT', '22', None, 1.0)

# manually computes the log probability of a given tree being generated by the above grammar
def log_probability(tree):
	ls = tree.as_list()
	# the probability is just the probability of the given noun phrase being generated, times the probability of the given verb phrase being generated
	prob_nounphrase = log_probability_nounphrase(ls[1])
	prob_verbphrase = log_probability_verbphrase(ls[2])
	return prob_nounphrase + prob_verbphrase

def log_probability_verb(ls):
	return math.log(1.0/3)

# the probability of a given verb phrase being generated
def log_probability_verbphrase(ls):
	# check if we went to a verb or not
	if ls[0] == 'VP':
		return math.log(0.5) + (log_probability_verb(ls[1]) + log_probability_nounphrase(ls[2]))
	else: return math.log(0.5) + log_probability_age(ls)

# probability of a given noun occurring
def log_probability_noun(ls):
	return math.log(1.0/2)

# probability of a given noun phrase occurring
def log_probability_nounphrase(ls):
	prob_det = 1.0 # there is only one determiner
	return math.log(prob_det) + log_probability_noun(ls[2])

def log_probability_age(ls):
	# compute the sum of all unnormalized probabilities for the rules INT --> x
	sum_prob_int = 12.0
	# check whether we have a bound variable or not
	if ls[2][0][0] == 'a2':
		prob_int = 10.0/sum_prob_int
	else: prob_int = 1.0/sum_prob_int
	return math.log(prob_int)

if __name__ == "__main__":
	for i in xrange(100):
		tree = g.generate()
		print tree, tree.log_probability()
